PEB

The process of determining the kernel32.dll base address involves making use of the Process Environment Block(PEB). 
The operating system allocates a structure for every running process that can always be found at fs:[0x30]from within the process.
The PEB structure holds information about the process’ heaps, binary image information, and, most importantly, three linked lists
regarding loaded modules that have been mapped into process space. The linked lists themselves differ in purposes from showing the
order in which the modules were loaded to the order in which the modules were initialized. The initialization order linked list is
of most interest as the order in which kernel32.dll is initialized is always constant as the second module to be initialized. It 
is this fact that one can take the most advantage of. By walking the list to the second entry, one can deterministically extract 
the base address for kernel32.dllmost advantage of. By walking the list to the secondentry, one can deterministically extract the 
base address for kernel32.dll

ASM to get base address of kernel32.dll: 

global _start

section .text

_start:
	int 0x03 			// breakpoint: comment and uncomment as needed

find_kernel32:
    push  esi  					      // preserve the esi reg
    xor   eax, eax 				    // zero out the eax reg
    mov   eax, [fs:eax+0x30]  // store address of PEB in eax (eax+0x30 eliminates nulls and saves a byte at the same time.)
    test  eax, eax				    // Bitwise compare eax with itself.
    js    find_kernel32_9x		// If SF is 1 then it's operating on a Windows 9x box. Otherwise, it’s runningon NT.*
find_kernel32_nt:
    mov   eax, [eax + 0x0c]		// Extract the pointer to the loader data structure
    mov   esi, [eax + 0x1c]		// Extract the first entry in the initialization order module list.
    lodsd						 // Grab the next entry in the list which points to kernel32.dll.
    mov   eax, [eax + 0x8]		// Grab the module base address and store it in eax.
    jmp   find_kernel32_finished // Jump to the end as kernel32.dll has been done
find_kernel32_9x:
    mov   eax, [eax + 0x34]		// Store the pointer at offset 0x34 in eax (undocumented).
    lea   eax, [eax + 0x7c]		// Load the effective address at eax plus 0x7c to keep us in signed byte rangein order to avoid nulls
    mov   eax, [eax + 0x3c]		// Extract the base address of kernel32.dll
find_kernel32_finished:
    pop   esi					        // Restore esi to its original value.
    ret							          // Return to the caller.
	
To build shllecode:

vi peb.bin
nasm peb.bin -o peb
hexedit peb

Shellcode:
CD 03 66 56  66 31 C0 64  66 67 8B 40  30 66 85 C0  78 13 66 67  8B 40 0C 66  67 8B 70 1C  66 AD 66 67  8B 40 08 EB  0F 66 67 8B  40 34 66 67  8D 40 7C 66  67 8B 40 3C  66 5E C3

sed -i 's/ /\\x/g' peb_shellcode.txt //To replace all whitespace chars in peb_shellcode with '\x' for use in python script
grep -o '\x' peb_shellcode.txt | wc -l // To get number of bytes

