SEH

The process of determining the kernel32.dll base address via this mechanism is to take advantage of the fact that the default 
Unhandled Exception Handler is set to use a function that exists inside kernel32.dll. On both Windows 9x and Windows NT based 
versions the top-most entry in the SEH list can always be found at fs:[0] from within the process. With this in mind, one can 
walk the list of installed exception handlers until they reach the last one. When the last one is reached the address of the 
function pointer can be used as a starting point for walking down in increments of 64KB, or 16×4096 byte pages. In Windows, 
DLL’s will only align on 64KB boundaries. At each 64KB boundary a check can be performed to see if the two characters at that 
point are ‘MZ’. These two characters mark the MSDOS header that is prepended to portable executables. Once a match is found it 
is safe to assume that the base address for kernel32.dll has been found.

ASM to get base address of kernel32.dll:

find_kernel32:
    push esi						// Preserve the esi register.
    push ecx						// Preverse the ecx register.
    xor  ecx, ecx					// Zero ecx so that it can be used as the offset to obtain the first entry inthe SEH list
    mov  esi, fs:[ecx]				// Grab the first entry in the SEH list and store it in esi.
    not  ecx						// Flip all the bits in ecx so that it can be used in the comparison later to determine if the last exception handler has been hit.
find_kernel32_seh_loop:				// 
    lodsd							// Load the next entry in the SEH list and store it in eax.
    mov  esi, eax					// initialize esi to the next entry in the list so that it’s ready should the codeneed to loop again
    cmp  [eax], ecx					// Compare the value at eax to see if its set to 0xffffffff. If it is, the last entry in the list has been reached and it’s function pointer should be inside kernel32.dll
    jne  find_kernel32_seh_loop		// If the values are not equal then the base address has not been found. Loopagain
find_kernel32_seh_loop_done:		// 
    mov  eax, [eax + 0x04]			// If the next entry in the list was equal to 0xffffffff, one knows the end has been hit. As such one can extract the function pointer for this entry and store it in eax.
find_kernel32_base:					// 
find_kernel32_base_loop:			// 
    dec  eax						// Decrement eax. If the previous value was aligned to a 64KB boundary,this will set us the low 16 bits of eax to 0xffff. If this is not the case it willsimply decrement eax to an undetermined value.
    xor  ax, ax						// Zero the low 16 bits of eax to align the address on a 64KB boundary
    cmp  word ptr [eax], 0x5a4d		// Check to see if the 2 byte value at eax is ’MZ’.
    jne  find_kernel32_base_loop	// If the values do not match, loop again and go to the next lower64KB boundary.  If they do match, drop down as the base address ofkernel32.dllhas been successfully found.
find_kernel32_base_finished:		// 
    pop  ecx						// Restore ecx to its original value
    pop  esi						// Restore esi to its original value
    ret								// Return to the caller
